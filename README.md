# Решение задачи "Понимание JVM"
*в GITHUB добавлен код без изменений, решение изложено в файле README.md*
## Подсистема загрузчиков классов (ClassLoader'ы)
Подсистема загрузчиков классов пытается загрузить класс JvmComprehension.java  
Bootstrap ClassLoader делегирует загрузку Platform ClassLoade,  
который в свою очередь делегирует загрузку Application ClassLoader  
Application ClassLoader находит и загружает класс JvmComprehension.java  
*по аналогичной схеме загружаются иные задействованные классы.*
### происходит подготовка классов к выполнению:
* Verify (проверка): проверка, что код валиден,
* Prepare (подготовка): подготовка примитивов в статических полях,
* Resolve (разрешение символьных ссылок): связывание ссылок на другие классы.
### Initialization (Инициализация): 
Выполняются static инициализаторы и инициализаторы static полей.
## Области памяти (стэк (и его фреймы), хип, метаспейс)
**Metaspace**  
Загруженные классы хранятся в области памяти: Metaspace  
*размер Metaspace в коде не изменен, соответсвенно по дефолту неограничен*  
**Stack Memory**  
В момент вызова метода создается фрейм(кадр) в стеке  
Порядок добавления фреймов:  
* main  
*создается примитивная переменная в фрейме main: int i = 1*  
*область видимости int i в фрейме main, значение хранится в фрейме main*  
*в куче создаются ссылочные переменные Object и Integer*  
*создаются ссылки на переменные в фрейме main: Object o и Integer ii*  
*область видимости ii и o в фрейме main, значение хранится в куче*  
* printAll  
*в фрейме printAll создаются ссылки на уже созданные переменные Object o и Integer ii*  
*создается примитивная переменная в фрейме printAll: int i = 1*  
*в куче создается ссылочная переменная Integer*  
*создается ссылка на переменную в фрейме printAll: Integer uselessVar*  
*область видимости uselessVar в фрейме printAll, значение хранится в куче*  
* System.out.println(o.toString() + i + ii)  
*в данном фрейме ссылка на строку, значение которой "o.toString() + i + ii" хранится в куче*
* toString()  
*в данном фрейме ссылка на существующую ссылочную переменную Object o, значение уже в куче*
* System.out.println("finished")  
*в данном фрейме ссылка на строку, значение которой "finished" хранится в куче*  
*размер Stack Memory в коде не изменен, соответсвенно настроен по дефолту*  

**heap (куча)**  
переменные хранящиеся в куче описаны выше  
*размер heap в коде не изменен, соответсвенно настроен по дефолту*  
## Движок выполнения  
все методы вызываются однократно, поэтому Just In Time (JIT) компилятор не задействован  
задействован Интерпретатор:  
байт-код в .class файле интерпретирует строка за строкой. Затем выполняет
## сборщик мусора (Garbage Collection)
сразу очищается по методу подсчета ссылок (reference counting) uselessVar с кучи, т.к. после создания нигде не используется  
остальные переменные будут очищены методом "обход графа достижимых объектов (mark-and-sweep, copying collection)"
